# Cache Service and Cache Pools

So we injected `HttpClientInterface` and did HTTP request to fetch some JSON data that we rendered on our website. But executing HTTP request on every page load is not a good idea because they are slow. You can notice how the homepage started loading longer than it was before. It would be great to cache the result for a moment because while the ISS moves super fast we don't need to be so exact. Let's talk about another service – the cache service. Open your terminal and run `bin console debug-autowiring-cache` to see if we already have any cache related services and we do. You may notice this `cache.app` aliases and we can already use it in our application. About this cache item pool. This is a term. Pools are just unique namespaces for cache items. You may think about it as subfolders in the global cache directory and so you can clean one cache pool without affecting others. We will talk about it later. For now the easiest way would be to use a `CacheInterface`, the one from the contracts. Go back to phpStorm and inject another service – `CacheInterface`. Choose one from contracts and let's call this cache. Now below copy these two lines and delete it and instead let's write `ISSData.EqualCache.Get`. The first argument should be the cache key. How about `ISSData.ISSLocation. Data`. And the second argument should be an anonymous function and let's paste the code below. But instead of setting the variable let's just return. And we have problems with client variable. To be able to use it in an anonymous function we need to use this client. I will also add array return time to the anonymous function. And now let's return back to the browser and refresh. As you can see we still hit the HTTP client request. But there is also a cache icon that shows something was written in the cache. `Cache writes 1`. Let's click this icon to open the profiler to see the cache panel. So how cool is that? We didn't create a custom pool for it so the default `app` pool is used. But you can create custom ones and we'll do it in a while. Go back to the home page. Go back to the home page. Refresh. And now the HTTP request is gone. And if you look at the cache tab there were no writes at all. And now the page loads super fast. I can even notice it myself. And now the data is cached forever unless we clear the cache. But for dev purposes let's set it to how about 5 seconds. In this anonymous function let's add `CacheInterface` as the first argument and call it `item`. And then inside Let's save. And now everything works perfectly. Let's call `item->expiresAfter()` and pass 5. The number we passed should be a number in seconds after which the cache will be expired. If you return back to your browser and refresh nothing will be changed because the value was already cached and so we need to manually clear it first so it will be recached with our time lifetime in five seconds. By default cache adapter is file system which means the cache is stored in the `var/cache/dev/pools/` directory. Here we can see our `app` folder which corresponds to our app cache. We could just drop this directory manually but there is a better way. Let's leverage a Symfony command. First open your terminal and run `bin console cache pool list`. You can see the list of available pools in our application. To clear the `cache.app` pool we can leverage another command which is `cache:pool:clear`. And then the `cache.app` which is the cache pool name. And the cache was successfully cleared. Now return back to the browser and refresh the page. Here is our HTTP request and if you quickly refresh again now the data we are used from cache. If you refresh one more time after five seconds here is our HTTP request again.
