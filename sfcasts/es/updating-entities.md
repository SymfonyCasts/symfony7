# Actualizaciones de barcos: Actualizar una entidad

¡Nuestro servicio de reparaciones va bien! Tenemos algunos clientes que repiten y quieren algunas actualizaciones posteriores. Necesitamos una forma de registrar una nave estelar existente cuyo estado sea completada.

La lista de nuestra página de inicio sólo muestra las naves incompletas, así que tenemos que encontrar una completada. Ejecuta en tu terminal:

```terminal
symfony console doctrine:query:sql 'SELECT slug, status FROM starship'
```

`lunar-marauder-1` es una nave completada. Copia la babosa, y de vuelta en la aplicación, visita `/starships/lunar-marauder-1`. Ya está. Para ver mejor la actualización, vamos a mostrar primero la fecha `arrivedAt` en la página de presentación. En `templates/starship/show.html.twig`, copia estas etiquetas `h4` y `p`. Pégalas a continuación. Actualiza el contenido de `h4` a `Arrived At`y el de `p` a `{{ ship.arrivedAt|ago }}`.

Vuelve a la aplicación, actualiza y ¡listo! Podemos ver que este barco está completado y que llegó hace 1 mes.

Para registrar una nave, crearemos un nuevo comando. En tu terminal, ejecuta:

```terminal
symfony console make:command
```

Para el nombre, utiliza `app:ship:check-in`. Esto ha creado una nueva clase de comando. En tu IDE, abre `src/Command/ShipCheckInCommand.php`. Actualiza la descripción a `Check-in ship`. Para el constructor, necesitamos lo mismo que para nuestro comando eliminar. Abre `ShipRemoveCommand`, copia el constructor y pégalo sobre `ShipCheckInCommand::__construct()`. También encontraremos la nave por slug, así que copia el método `configure()` de `ShipRemoveCommand` y pégalo también.

La primera parte de `execute()`, encontrar el barco por slug, es también la misma que `ShipRemoveCommand`. Cópiala y pégala. Actualiza el comentario IO a "Comprobando nave estelar...".

Es hora de la lógica real de "registro". Primero, actualiza la fecha de llegada a la hora actual con `$ship->setArrivedAt(new \DateTimeImmutable('now'))`. A continuación, establece el estado a "esperando" con `$ship->setStatus(StarshipStatusEnum::WAITING)`. Estos campos se han actualizado, así que, a continuación, llama a `$this->em->flush()` para guardar los cambios en la base de datos.

¡Espera, espera, espera! Cuando persistimos o eliminamos una entidad, teníamos que llamar a un método del gestor de entidades para que Doctrine supiera nuestra intención. ¿Aquí no lo hacemos? ¡No! Doctrine es superinteligente. Arriba, cuando encontramos la entidad, Doctrine empezó a rastrearla. Cuando llamamos a `flush()`, ve que se ha modificado y determina el mejor SQL para actualizar la base de datos. ¡Asombroso!

Por último, añade un mensaje de éxito para el comando: "Nave estelar registrada".

De vuelta a nuestra aplicación, ésta es la nave que queremos registrar. Copia el slug de la url. En tu terminal, ejecuta nuestro nuevo comando con:

```terminal
symfony console app:ship:check-in
```

pega el slug y ¡ejecuta! ¡Éxito! De vuelta en la aplicación, actualiza la página. Ahora el barco está marcado como "esperando" y ha llegado hace 9 segundos. ¡Ha funcionado!

Vuelve a la lógica de registro dentro de `ShipCheckInCommand`. Estamos llamando a setters para actualizar dos campos. A continuación, vamos a encapsular esta lógica en un método de la entidad`Starship`.

Muy bien, nuestro servicio de reparaciones ha tenido éxito y tenemos algunos clientes habituales. Se trata de barcos que han terminado sus reparaciones o actualizaciones y ahora quieren volver. Así que lo que necesitamos es una forma de registrar una nave completada existente. Lo que haremos es actualizar la llegada y el estado de completado a en espera. Así que lo primero que podemos hacer, lo primero que deberíamos hacer es buscar una nave completada. Recordarás que aquí no listamos las naves completadas. Sólo listamos las naves en progreso y en espera en la cola. Así que saltaremos a nuestro terminal y ejecutaremos una consulta para encontrar naves completadas. Hagamos esto Symfony doctrine query sql select slug status from nave. Symfony console doctrine query sql select slug status from starship. Bien, cojamos esta nave lunar marauder-1. Vamos a coger este slug y copiarlo porque es una nave completada. Y luego, de vuelta en nuestro navegador, haremos starship /lunar marauder-1 para obtener su página de presentación. Haz nave estelar /lunar marauder-1 para obtener su página de presentación. Perfecto. Para ver mejor la actualización, me gustaría que mostráramos la fecha de llegada aquí abajo en la página de presentación. Así que vamos a añadirlo rápidamente. Así que si volvemos a nuestra aplicación y en plantillas, mostrar nave estelar, en la parte inferior aquí donde estamos escribiendo estos detalles, copia estas dos líneas, esta etiqueta h4 y p, y luego abajo pega. Y actualizaremos el estado de la nave a llegada. Y los datos de abajo, los datos de esto serán ship.arrived at ago para mostrar esa bonita fecha. Ahora vamos a actualizar. Vale, perfecto. Así que podemos ver que este barco está completado y que llegó hace un mes. Así que para realizar el registro, vamos a crear otro comando. Así que en tu terminal, consola Symfony crea el comando. Y llamaremos a esta aplicación check-in ship. Vale, y podemos ver que lo ha creado en origen el comando ship check-in command. Así que de vuelta en nuestro IDE, vamos a encontrar ese comando source comando ship check-in. Perfecto. Ya tenemos aquí el nombre para la descripción. Llámalo check-in in ship. Para el constructor, va a ser lo mismo. Necesitamos el repositorio de la nave estelar y la interfaz del gestor de entidades. Así que podemos copiar eso del comando que creamos en el último capítulo y copiar todo el constructor. Y luego aquí, pegar e importar esto. Perfecto. Y vamos a registrar por slug, igual que hicimos en el comando eliminar nave. Así que también podemos copiar el método configure y pegarlo encima del del constructor. Y ahora para ejecutar, en realidad la primera parte de este comando va a ser bastante va a ser la misma. Vamos a coger el slug del argumento. Vamos a lanzar un error si no se encuentra la nave. Vamos a seguir teniendo un comentario aquí. Así que vamos a copiar eso y luego lo ajustaremos. Así que coge todo esto y cópialo. Y luego en el registro del barco, pegaremos aquí. Vale, pues lo mismo. Intentamos encontrar el barco. Si no se encuentra, lanzamos un error. Y en vez de eliminar nave estelar, lo llamaremos facturar nave estelar. Vale. Ahora lo que necesitamos es la lógica. Como hemos dicho, el paso de registro de entrada, la lógica de registro de entrada va a ser coger la nave y establecer su llegada que a la nueva fecha hora inmutable. Ahora la fecha actual. Y también vamos a establecer el estado de la nave a estado de la nave estrella enum esperando, porque ese es el primer estado cuando se registra una nave, simplemente se marca como esperando. Y para el éxito. Vale, estos campos se han actualizado en nuestra entidad nave estelar, pero aún no se han guardado en la base de datos. ¿Cómo podemos hacerlo? Puede que lo hayas adivinado. Esta em descarga. Espera un momento. En los comandos de eliminación persistente, teníamos que llamar a métodos específicos del gestor de entidades persistir y eliminar, pero aquí no tenemos que hacerlo. Pero aquí no tenemos que hacerlo. Esto se debe a que cada vez que cambiamos una entidad, en realidad se almacena en la memoria y es rastreada por la doctrina. Y rastrea todos los cambios que se hacen en tu código a la entidad. Así que cuando llamemos a flush, detectará que esta nave ha sido cambiada, y creará automáticamente las consultas para guardar ese cambio en la base de datos. Genial. Así que ahora nuestro mensaje de éxito al final, nave estelar registrada. Perfecto. Bien, comando ejecutado. Vamos a registrar esta nave. Así que copiaremos la babosa como hicimos antes. Y de vuelta al terminal, ejecutaremos el comando Symfony console app ship check in lunar marauder one. Muy bien, nave registrada. Y si volvemos atrás y actualizamos la página, deberíamos ver algunas actualizaciones aquí. Y las vemos. Ahora está marcada como en espera y ha llegado hace 9 segundos. Si volvemos a lo nuestro nuestro comando de registro está funcionando como se esperaba. Si volvemos a nuestro código para el comando de check in, puedes ver la lógica que tenemos esto, la lógica que hemos creado para en para ejecutar un check in, podemos ver que estamos cambiando algunos campos utilizando los setters en en el barco. Creo que sería mejor encapsular esto en un método específico de la entidad para que sea más descriptivo y explícito lo que estamos haciendo. Además. Hagámoslo a continuación.
