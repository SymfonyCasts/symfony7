WEBVTT

00:00:01.076 --> 00:00:06.396 align:middle
Es hora de hablar de los Repositorios de Entidades, un lugar
donde "acoplamos" consultas personalizadas para una entidad.

00:00:06.996 --> 00:00:11.736 align:middle
En el controlador de la página de inicio, escribimos una consulta
con el constructor de consultas para encontrar todos los barcos.

00:00:12.106 --> 00:00:16.996 align:middle
Esto está bien, pero si necesitáramos utilizar la
misma consulta en otro lugar, tendríamos que duplicarla.

00:00:17.306 --> 00:00:20.766 align:middle
Y si quisiéramos cambiarla, tendríamos
que hacerlo en varios sitios.

00:00:21.026 --> 00:00:24.386 align:middle
¡Qué asco! ¡Repositorios
de entidades al rescate!

00:00:24.896 --> 00:00:27.566 align:middle
Espera, ¿no había creado
make:entity uno de estos?

00:00:27.926 --> 00:00:31.326 align:middle
¡Pues sí! Para coger el objeto
repositorio de una entidad,

00:00:31.626 --> 00:00:39.546 align:middle
prueba dd($em->getRepository(Starship::class)):
Vuelve a la aplicación y actualízala.

00:00:40.496 --> 00:00:44.696 align:middle
¡Genial! Tenemos un objeto
App\Repository\StarshipRepository.

00:00:45.276 --> 00:00:51.326 align:middle
Echa un vistazo a esta clase:
src/Repository/StarshipRepository.php.

00:00:51.326 --> 00:00:56.556 align:middle
Primero, si tienes curiosidad por saber cómo sabe Doctrine
que esta clase es el repositorio de la entidad Starship,

00:00:56.886 --> 00:01:00.006 align:middle
salta a src/Entity/Starship.php.

00:01:01.036 --> 00:01:07.806 align:middle
Ah, el atributo #[ORM\Entity] tiene
repositoryClass: StarshipRepository::class:

00:01:08.356 --> 00:01:12.076 align:middle
Cada entidad -como Starship -
tiene su propia clase repositorio.

00:01:12.516 --> 00:01:16.086 align:middle
Está vacía para empezar, pero pronto la
llenaremos con consultas personalizadas.

00:01:16.496 --> 00:01:17.986 align:middle
Además, ¡es un servicio!

00:01:18.316 --> 00:01:20.096 align:middle
Eso significa que podemos autoconectarlo.

00:01:20.836 --> 00:01:23.296 align:middle
En el controlador de la página
de inicio, elimina este dd().

00:01:23.836 --> 00:01:30.536 align:middle
Simplifiquemos: sustituye EntityManagerInterface
por StarshipRepository $repository:

00:01:31.196 --> 00:01:36.486 align:middle
Esta consulta que escribimos antes, para obtener todos
los barcos, es tan común que todos los repositorios

00:01:36.486 --> 00:01:40.506 align:middle
tienen un atajo para ella:
findAll(): ¡Mucho más bonito!

00:01:41.066 --> 00:01:42.556 align:middle
De vuelta en la aplicación, actualiza.

00:01:43.306 --> 00:01:44.416 align:middle
¡Sigue funcionando!

00:01:44.876 --> 00:01:47.796 align:middle
Usémoslo también en
StarshipController::show().

00:01:48.416 --> 00:01:52.936 align:middle
Sustituye EntityManagerInterface
por StarshipRepository $repository:

00:01:53.716 --> 00:01:57.236 align:middle
¡Cada repositorio también viene
pre-construido con un método find()!

00:01:57.636 --> 00:02:02.326 align:middle
Y como éste es el repositorio Starship,
no necesitamos pasar la clase de entidad,

00:02:02.506 --> 00:02:07.686 align:middle
sólo la $id: Vuelve a la aplicación,
actualiza y haz clic en una nave estelar.

00:02:08.366 --> 00:02:10.266 align:middle
Sigue funcionando, ¡perfecto!

00:02:11.196 --> 00:02:14.426 align:middle
De vuelta en el controlador de la página de
inicio, en lugar de encontrar todas las naves

00:02:14.676 --> 00:02:18.466 align:middle
, ¿qué pasa si necesitamos encontrar sólo
las naves cuyo estado no sea completed:

00:02:18.766 --> 00:02:21.036 align:middle
es decir, sólo waiting o in progress.

00:02:21.536 --> 00:02:22.866 align:middle
¡Necesitamos una consulta personalizada!

00:02:23.256 --> 00:02:27.996 align:middle
Pero esta vez, en lugar de escribirla en el
controlador, vamos a organizarla en el repositorio.

00:02:28.616 --> 00:02:33.096 align:middle
Añade un nuevo método public function
findIncomplete() que devuelva un array.

00:02:33.676 --> 00:02:39.506 align:middle
Incluye un docblock para que nuestro IDE sepa
que será una matriz de objetos Starship: Dentro,

00:02:39.536 --> 00:02:42.606 align:middle
return $this->createQueryBuilder('e').

00:02:42.746 --> 00:02:46.826 align:middle
Esto es sólo un alias para la entidad:
lo necesitaremos en un segundo.

00:02:47.566 --> 00:02:51.786 align:middle
Lo bueno de crear un constructor de consultas
en un repositorio, es que no necesitas

00:02:51.786 --> 00:02:55.326 align:middle
especificar el select() o
from() como en el controlador.

00:02:55.686 --> 00:02:56.796 align:middle
Se hace automáticamente.

00:02:57.436 --> 00:03:04.456 align:middle
Todo lo que tenemos que hacer es añadir
->where('e.status != :status').

00:03:05.126 --> 00:03:11.926 align:middle
e.status es el nombre de la propiedad en la entidad Starship
y :status es un marcador de posición para un valor.

00:03:12.586 --> 00:03:19.686 align:middle
Pásale un valor con ->setParameter('status',
StarshipStatusEnum::COMPLETED).

00:03:20.566 --> 00:03:24.916 align:middle
Este :status de aspecto tonto y el
setParameter('status', ...) inmediato

00:03:25.036 --> 00:03:25.816 align:middle
son importantes.

00:03:26.626 --> 00:03:30.446 align:middle
Nunca incluyas el valor real
en la consulta por dos razones.

00:03:30.786 --> 00:03:35.546 align:middle
En primer lugar, Doctrine puede optimizar ligeramente el rendimiento
de la consulta cuando se utilizan marcadores de posición.

00:03:36.056 --> 00:03:41.226 align:middle
En segundo lugar, y más importante, ¡los marcadores
de posición evitan los ataques de inyección SQL!

00:03:41.726 --> 00:03:45.926 align:middle
Si pensabas que El Borg era malo, ¡realmente
odiarás los ataques de inyección SQL!

00:03:46.546 --> 00:03:54.106 align:middle
Para terminar la consulta, añade ->getQuery() y ->getResult():
De vuelta en el controlador de la página de inicio,

00:03:54.106 --> 00:03:58.526 align:middle
sustituye findAll() por
findIncomplete(): Vuelve a girar.

00:03:59.046 --> 00:04:01.336 align:middle
Deberíamos ver desaparecer
esta nave terminada.

00:04:02.176 --> 00:04:03.996 align:middle
¡Lo vemos! ¡La consulta funciona!

00:04:04.466 --> 00:04:08.616 align:middle
Comprueba el perfilador: vemos la consulta
y el parámetro que hemos utilizado.

00:04:10.136 --> 00:04:13.216 align:middle
De vuelta en el controlador, no
me gusta esta lógica de $myShip.

00:04:13.486 --> 00:04:17.626 align:middle
Y no es porque estemos falseando la idea
de "mi nave" al coger sólo la primera.

00:04:18.076 --> 00:04:21.856 align:middle
Es porque, sea cual sea la lógica,
ésta debería estar en el repositorio

00:04:21.856 --> 00:04:24.366 align:middle
para que podamos encontrar "mi
nave" siempre que la necesitemos.

00:04:24.976 --> 00:04:29.796 align:middle
En StarshipRepository, añade un nuevo
método public function findMyShip()

00:04:29.896 --> 00:04:31.836 align:middle
que devuelva un objeto Starship.

00:04:32.356 --> 00:04:35.896 align:middle
Podemos imaginar que este método tomaría
un usuario o algo para encontrar su nave,

00:04:36.206 --> 00:04:41.996 align:middle
pero por ahora, sólo devuelve $this->findAll()[0]
para obtener la primera nave de la tabla:

00:04:42.716 --> 00:04:44.736 align:middle
De vuelta en el controlador, sustituye esto

00:04:44.736 --> 00:04:49.536 align:middle
por $repository->findMyShip():
¡Así se lee mejor!

00:04:50.056 --> 00:04:51.686 align:middle
Vuelve a la aplicación y actualiza.

00:04:52.546 --> 00:04:53.416 align:middle
¡Sigue funcionando!

00:04:53.916 --> 00:04:56.426 align:middle
Mira el perfilador: ¡dos consultas!

00:04:56.656 --> 00:05:01.706 align:middle
La primera encuentra todas las naves incompletas
y la segunda es la findAll() de findMyShip().

00:05:02.166 --> 00:05:05.576 align:middle
¡Perfecto! A continuación,
mejoremos nuestros accesorios

00:05:05.576 --> 00:05:09.316 align:middle
y hagámoslos 100 veces más divertidos
con una biblioteca llamada Foundry.

00:05:09.816 --> 00:05:13.506 align:middle
Esto nos permitirá crear toda una flota de naves
estelares como si tuviéramos un replicador.

00:05:13.876 --> 00:05:14.576 align:middle
¡Hagámoslo!
