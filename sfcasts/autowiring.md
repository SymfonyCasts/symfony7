# How autowiring works

Let's run our favorite command again – `bin/console debug:autowiring`. It shows us a list of services that we can autowire in our code, but that's not all services in our Symfony application. But how does autowiring actually work? Let's run another command – `bin/console debug:container`. You see a huge list of services and any service id that happened to be a class or interface name is autowirable. This means we can literally type hint it in constructor of our service and service container will inject us that service. And so, if a service id is not in an interface or class name, it is not autowirable. And most services are this way on purpose as they are low-level services that just exist to help other services behind the scene. You probably never need to use those low-level services directly, so that's why you cannot fetch them via autowiring. But that's why `debug:container` has so many more entries in comparison to `debug:autowiring` command. The service container is basically a giant array where each service has a unique name that points to the corresponding service object. For example, like this – `twig` ID. Container knows that to instantiate this `twig` service it should create an instance of this `Twig\Environment` class and even if we don't see the arguments here, it knows which arguments exactly should be passed to instantiate it. And yes, if you request for the same service in a few places, service container will only create it once, so in all places you will have the exact same instance of it. Also, you may notice these service classes, for example, this `CacheInterface` we used earlier is an alias for a cache-app service. It's just a way to make a service like `cache.app` autowirable. You may notice that vast majority of services are written in SNAE case-naming strategy. But to allow you to be able to autowire it in your code, bundles add some aliases which IDs are class names or interfaces so that you could type-hint them in your code. So aliases are just like symbolic links, they just refer to other services. But it also might be so that there are times when there are multiple services in the container that implement the same class or interface. So, head back to phpStorm and create our custom cache pool. In `config/packages/cache.yaml`. In the `yaml` file, I will uncomment the `pools` key and instead of this example I will write `iss_location_pool: null`. Now, back to the terminal and run `bin/console debug:autowiring`. So, to see a new service. As you can see, in this case the configuration added a totally new service, our `iss_location_pool` service, which is also the same cache interface as `cache.app` service. Open phpStorm and in `src/Controller/MainController` in `homepage()` let's change the variable name to `$issLocationPool` and keep the `CacheInterface` type-hint the same. Below, update the variable name too. That's so-called "named autowiring", when service container also looks at variable name along with its type-hint to inject the correct service. It's rare, but you can also see it with `logger` service, for example. Now, back to the browser, update the page and check the cache profile. Here is our `iss_location_pool` and our ISS location data is written to that pool. So, if we ever need to clear the cache for this pool, we can open our terminal and run the command `bin/console cache:pool:clear iss_location_pool`. And it will only clear the cache for this exact pool without affecting other pools. Also, we can configure this pool a bit differently from other pools. For example, let's set expiration time for our new pool in the config file instead of doing it in php. Open your PhpStorm and in `cache.yaml` instead of null let's go to the nested level and write `default_lifetime: 5` which means 5 seconds. This will affect all the cache items in this pool. Now, head back to the `MainController` and now we can remove this `item->expiresAfter()`. And also, we don't need this `item` argument at all. To make sure everything works, let's go to the browser, open the home page again and no errors. Next, let's talk about environments that help us using different configurations locally versus production.
