# Services: The Backbone of Everything

Coming Soon...

Let's talk about services. These are the most important concept in Symfony. Once you understand them, you can really do anything. First, a service is an object that does work. That's it. For example, if you add a logger object with a log method, that's a service. It does work. Or a database connection object that makes queries to the database. What's an example of a class that's not a service? Our Starship class is a perfect example. It's main job is not to do work, but instead to hold data. Sure, it has a few public methods, and you could even put some logic inside of these methods to do something. But ultimately, it's not a worker, it's a data holder. What about a controller? Yeah, that's technically a service too. It's work is to create response objects. Anyway, every bit of work that's done in Symfony is actually done by a service. Logging log messages to this file? Yeah, there's a service for that. Figuring out which route matches the current URL? That's the router service. What about rendering a twig template? Yep, turns out that this render method is just a shortcut to go and call a method on a service object. Now internally, while it's not super important, you'll often hear that these services are organized into a big object called the service container. It's like a giant associative array of service objects, each with a unique ID. Want to see a list of every service in our app right now? Me too. Find your terminal and run bin console debug container. I'm actually going to make this smaller. There we go. We can see everything on one line. What we're seeing here is on the left, this is the ID of the service. On the right, it's telling you what type of object corresponds to that ID. Cool, right? If we go back and open up our JSON, hold control or command to open up the JSON method, this now makes more sense. It's checking to see if the container has a service whose ID is serializer. If it does, it grabs that service from the container and calls the serialized method on it. Now, when we work with services, it won't quite look like this, but we now understand what's going on. And that is so important.  My next question is where do these services come from? Like what says there's a service whose ID is twig and that when I ask for it gives me a twig environment object? The answer is entirely from bundles. In fact, that's the main point of installing a new bundle. Bundles give us services. Remember when we installed twig? Well, we actually, when we did that, it actually added a bundle to our project. And guess what that bundle did? You guessed it. It gave us new services, including this twig service. Bundles give us more services and services are tools. Now, in reality, we're never going to need to use the vast majority of the services in this list, nor are we going to care about this internal ID most of the time. Instead, I'm going to make this big again. Run a related command called bin console debug auto wiring. This shows us all of the services that are auto-wireable. Basically all of the services that are meant to be used by us. These are services where symphony makes it a little extra, a little easier for us to access them. So let's do a challenge. Let's log something from our controller. The way I approach this problem is I think, okay. Logging is work. All work is done by a service. So if I want to log something, I just need to find the logger service. Okay. So let's rerun this command again and search for a log and boom, it actually finds about 10 services, all starting with this PSR log logger interface. Now we're going to talk about logger interface. Now we're going to talk about what these other services are in the next tutorial. Right now, I just want you to focus on this one. What this tells me is that there is a service in the container for a logger. And if I want to get it, I can auto-wire it using this interface. So the way you do that is in the controller method, where you want the logger, you add an argument with that type headed with that logger interface. So I'll hit tab and then say logger. Now the name of the argument isn't important. The important thing is the logger interface that corresponds to this use statement up here. So PSR log logger interface matches PSR log logger interface.  So it's really simple. Symfony is going to see this type hint and say, oh, since that matches this type in here, they must want us to pass the, this service object there. See if this is working. Let's DD logger, DD logger, which stands for dump and die. That's also a symphony function that as you can see, prints a really nice dump of the object and then dies. And the point is it's working. It passes us a monologue slash logger object, which implements that, that logger interface, which interface. This trick is called auto wiring and it works in two places in controller methods and also constructor methods of other services. And we'll see that in the next chapter. If you're wondering where this logger service came from, we already know the answer from a bundle in this case, from monologue bundle. And how do we get from a bundle in this case from monologue bundle and how do we configure that service and tell it, I don't know where to log config packages monologue.yaml. This configuration, including this line right here, configures the monologue bundle. The monologue bundle is what gives us this service. This percent syntax is a little fancy, but that actually is what configures the logger service to log to this dev.log file. All right, let's try using this. How do we? Well, we could read the docs, but we have this type in here, so our editor is going to help us. It has a bunch of methods on it. Let's use info and I'll say starship collection retrieved. And when we move on refresh, the page works. Did it actually log something? Well, we could tail the dev.log file and look at there, but remember, we can also see log information in the profiler for request. Because this is an API request, we don't have a web debug toolbar on the bottom, but there is still a profiler that was created with information about this request, and we can totally go check it out. To do that, change the URL to slash underscore profiler. This gives a list of all the most recent requests to your application with the newest on top. See this one right there? That's the API request we made a second ago.  If you click this token, boom, we're looking at the profiler and all the information for that API recall, including our log message. Now that we've seen how to use a core service, how to use a service, let's create our own service next to organize our code.
