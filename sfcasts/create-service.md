# Creating your own Service

Coming Soon...

Okay, we know that services do work, and we know that Symfony is full of services that we can use. If you run bing-console-debug-autowire, autowiring, we can fetch any of these services by type hinting their class or interface. We of course also do work in our code, and right now all of that work is being done right inside of our controller, like creating the Starship data. Sure, this data is hard-coded right now, but imagine if this was real work like a complex database query. Having this logic right inside a controller, it works. There's nothing super wrong with it. But what if we wanted to reuse this logic somewhere else? What if on our homepage we wanted to actually get a dynamic count of the Starships by leveraging this same data here? To do that, we need to move this work into its own service. In the source directory, create a new repository directory, and then a new PHP class called StarshipRepository. Just like when we built our Starship class, this new class has absolutely nothing to do with Symfony. It's just a class that we've decided to create to organize some work, and so Symfony doesn't care what this is called or what it looks like. I called it a StarshipRepository and put it in a repository directly just because that's a common programming pattern. If you have a class whose work is to retrieve a type of data, like Starship data, we often call that a StarshipRepository, but you can call this whatever you want. All right, before we even do anything in here, let's see if we can use this inside of a controller. Up top, just by creating this class inside of the source directory, it's actually already available for us to auto-wire in our code. Add a StarshipRepository, repository argument, and then just to make sure it's working, I'm going to ddRepository. All right, so spin over, I'll click back to our endpoint, and got it. Just by adding that type int, Symfony instantiated that object for us and passed it. Delete the dd, and let's move the Starship data in. So I'll copy that and create a new public function called, how about findAll. Again, you can call that whatever you want. Here I'll return, and then paste. Awesome. Over in Starship API controller, delete that, and it's just beautifully simple.  Starships equals repository arrow, findAll. That's it. And when we try it, it still works like before, but now we have our code kind of nicely, like isolated and organized into this new service. Okay, so let's get a little bit more complex. What if from inside StarshipRepository, we needed access to another service to help us do our work? No problem. We can use auto-wiring just like we did earlier for the logger. But this time, we're not going to add it as a method to findAll, and I'm going to explain why in a second. Instead, add a new public function, underscore, underscore, construct, and do the auto-wiring there. Private logger interface, logger. And down below to use it, I'm actually going to copy the code from our controller. Delete that, paste it here, and we'll say thisErrorLogger. Cool. Over in our controller, I'll remove that argument just because we don't need it anymore. Let's try it. Refresh. And no error, which is already good, which is already a good sign. Let's see if it actually logs something. Go to slash, underscore, profiler, and click on the top request, logs, and there it is. So let me explain why we added this to a constructor. If you want to fetch a service like the logger, this is actually the correct way to do it. Add a construct method from inside another service. The trick we saw earlier by adding it to a specific method, yeah, that's a special thing that only works for controller methods. It's a little extra convenience that was added to the system. It's a great feature, but the constructor way, that's the normal way that auto-wiring works. And this way, this constructor thing even works in a controller. You could put a construct method here, and that would totally work. So if you aren't a controller, auto-wire through the method, but just realize that's a special thing that only works there. Everywhere else, we're going to follow this pattern. All right, let's celebrate our new service by using it on the homepage. So open up main controller. Instead of this hard-coded Starship count, let's auto-wire StarshipRepository, StarshipRepository. Then I'll say ships equals StarshipRepository arrow find all, and then we can just do a count with count of ships.  And also while we're here, instead of having this hard-coded ship array, let's grab a random Starship object. We can do that by saying my ship equals ships, left square bracket, array rand, ships. And when we move over and head to the homepage, it works. We can see our randomly changing ship down here, and the correct ship number because we're multiplying it by 10 in the template up there. But something extra cool just happened. A minute ago, my ship was an associative array. We just changed it to be a Starship object. And yet, the code on our page kept working. We've just accidentally seen a superpower of Twig. Head to templates, main, homepage.html, Twig, and scroll down to the bottom. When you say my ship dot name, Twig is really smart. If my ship is an associative array, it'll grab the name key. If my ship is an object like it is now, it will grab the name property. But even more than that, if you look in Starship, the name property is private, so you can't access the name property directly. But Twig realizes that. It looks at the name property, sees that it's private, but also sees that there's a get name method. And ultimately, that's what Twig is calling behind the scenes. So we need to say my ship dot name, but Twig's doing some extra work behind the scenes to grab that in the correct way, which I love. All right, while we're here, let's do one last little tweak. Instead of passing in the Starship count to our template, we can do the count inside of Twig. So I'll delete this variable, and instead, pass all of ships into the template. And in the template, there we go, for our count, we can say ships, which is an array, and then use a Twig filter, so pipe, and then length. Love that. Let's do the same thing down here. And do it greater than two. When we try that, that works just like before. All right, next, let's create more pages, learn how to link between those, and how we can make our routes smarter.
