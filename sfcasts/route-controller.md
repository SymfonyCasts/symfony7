# Routes, Controllers & Responses

Coming Soon...

Ok, here's the setup for our project. Wesley Crusher, everyone's favorite ensign from Star Trek, has retired from Starfleet and is working with us to start a new business, Wesley's Star Shop. Someone's gotta break the monopoly that the fringy have on the galaxy's starship repair business, and he's hired us to build the site to do that. We got this. And it starts with building our first page. The idea behind any page is always the same. First, we define its URL. That's called the route. Second, we write a PHP function with code that generates the page. That's known as the controller. And that page could be HTML, JSON, ASCII art, anything. In Symfony, the controller is always a method inside of a PHP class. So, we need to create our first PHP code. Where does PHP code live in our app? That's right, the source directory. Inside this source controller directory, I'm gonna create a new PHP class. Now, I would normally select PHP class, but for this first time, I'm just gonna select file and do it by hand. I'll call it maincontroller.php, but you can name this however you want. Inside of there, we'll do the open PHP tag, and then say class maincontroller. Then above this, give it a namespace of app slash controller. Okay, a couple things about this. First, the fact that I put this class inside of a directory called controller is totally optional. That's a convention in Symfony to organize our controllers into this directory. But you could rename that to Klingon, and everything would work just fine. However, there are some rules about PHP classes in general in your project. The first is that every PHP class must have a namespace, and that namespace needs to match your directory structure. It's always going to be app slash, and then whatever controller you're, whatever directory you're inside of. This is, without going into too much detail, this is basically a rule in all of PHP. The second part of that rule is that your class name must match your filename.php. All right, to actually make our controller, add a new public function. I'm going to call it homepage, but you could call it anything. But remember, a page is a route, which defines the URL and a controller. So where do we put the route?  The answer is right above the controller method. We're going to use what's, we're going to use something called a PHP attribute. You do pound sign bracket, and then start typing route. And notice we get auto-completion here. Both of these would work, but use the one from attribute. I'm going to hit tab, and what I do, this is going to add a use statement on top, and that's really important. Anytime you reference a PHP attribute, you must have a corresponding use statement for it. Now these attributes work almost like PHP functions. You can pass this a bunch of arguments. The first one's the path, so I'm just going to say slash. So this means when someone goes to the homepage, slash, Symfony is now going to call this method to build that page. What does our method in here return? Well, we just need to return the HTML, right? Or the JSON if we're building an API. Well, yes, but we don't need to do that. The web works on a really well-known system. First, a user requests a page. They say, hey, I want to see slash products, or I want to see slash users.json. What we return back to them, yes, is HTML or JSON, but it's more than that. We also communicate back a status code, which says whether or not the response was okay or had an error, and we return back things called headers. This whole package is called a response. So yeah, most of the time, we're just going to be thinking about returning HTML or JSON, but actually, it's this bigger thing called a response. Anyway, our entire job as web developers, no matter what language we're programming in, is to understand the request and return response. One of my favorite things in Symfony is that in our controller, we're actually going to return a new response object from Symfony. Again, notice when we reference this class name, it also gives us some options. The one we want is from Symfony component HTTP foundation. The HTTP foundation component is a component in Symfony that has things related to requests and responses. So I'll hit tab. And once again, when I hit tab, that added a use statement on top. I'm going to use that all the time in P3Storm.  Anytime you reference a class name, you must have a corresponding use statement. Inside this response, the first argument is just the content that we want to return. So I'll hit tab. And once again, when I hit tab, that added a use statement on top. I'm just going to start with a hard coded string. All right, let's try it. All right, let's back out of our browser. This first page we saw here is just an internal demo from that Symfony shows us when we don't have a real page configured. But now that we do when we refresh, there it is. I know it's not much yet. But we just learned the first big fundamental part of Symfony, that every page is a route controller, and our controller returns a response. And it's optional. But since our controller is always going to return a response, we can add a response return type if we want to. That doesn't change anything, but it does make our code more descriptive. And if we ever did something, if we ever did something silly and returned something other than a response, it's going to give us a better error. All right, next, to supercharge our development, we're going to install our first third party package and learn about Symfony's amazing recipes system.
